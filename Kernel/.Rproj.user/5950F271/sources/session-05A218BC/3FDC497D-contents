Sys.setlocale("LC_ALL", "pt_br.utf-8") 
gc(T)
rm(list = ls())

if (!require(shinycssloaders)) install.packages("shinycssloaders")

library(shiny)
library(leaflet)
library(sf)
library(dplyr)
library(readr)
library(tidyverse)
library(leaflet.extras)
library(shinycssloaders)
library(sp)

# Banco de dados
CTF_BRASIL <- readxl::read_xlsx("./CTF2024/CTF_BRASIL_filtrado.xlsx")


# Defina os limites geográficos aproximados do Brasil
limites_brasil <- list(
  lat_min = -33.7,  # Latitude mínima do Brasil
  lat_max = 5.3,    # Latitude máxima do Brasil
  lon_min = -73.9,  # Longitude mínima do Brasil
  lon_max = -34.8   # Longitude máxima do Brasil
)

#NAO FILTRAR- DEIXAR EM OUTRA COR  os pontos dentro dos limites do Brasil
CTF_BRASIL <- CTF_BRASIL %>%
  filter(Latitude >= limites_brasil$lat_min & Latitude <= limites_brasil$lat_max &
           Longitude >= limites_brasil$lon_min & Longitude <= limites_brasil$lon_max)

# Interface do usuário (UI)
set.seed(42)
ui <- fluidPage(
  titlePanel("Pontos de Atividades no Brasil por Região"),
  sidebarLayout(
    sidebarPanel(
      selectInput("regiao", "Selecione a Região:", c("Todos", choices = unique(CTF_BRASIL$Região))),
      selectInput("estado", "Selecione o Estado:", choices = NULL),
      selectInput("potencial", "Selecione o Potencial Poluidor:", choices = c("Todos", unique(CTF_BRASIL$Potencial_de_Poluicao_da_atividade))),
      selectInput("categoria", "Selecione a Descrição da Categoria:", choices = c("Todos", unique(CTF_BRASIL$Descricao_da_categoria))),
      selectInput("situacao", "Selecione a Situação Cadastral:", choices = c("Todos", unique(CTF_BRASIL$Situacao_cadastral)))
    ),
    mainPanel(
      leafletOutput("map")
    )
  )
)

# Defina as cores para as situações cadastrais
cores_situacao <- c("Ativa" = "green", "Suspensa para Averiguações" = "yellow", "Encerrado" = "red")

# Defina um conjunto de cores para as categorias (aqui usamos uma paleta básica, mas pode ser ajustada conforme necessário)
categorias_unicas <- unique(CTF_BRASIL$Descricao_da_categoria)
cores_categoria <- rainbow(length(categorias_unicas))
names(cores_categoria) <- categorias_unicas

# Servidor (Server)
server <- function(input, output, session) {
  # Atualize as opções de estado com base na região selecionada
  observeEvent(input$regiao, {
    estados <- CTF_BRASIL %>%
      filter(Região == input$regiao) %>%
      pull(Estado) %>%
      unique()
    updateSelectInput(session, "estado", choices = c("Todos", estados))
  })
  
  # Renderize o mapa
  output$map <- renderLeaflet({
    data <- CTF_BRASIL %>%
      filter(Região == input$regiao)
    
    if (input$estado != "Todos") {
      data <- data %>%
        filter(Estado == input$estado)
    }
    
    if (input$potencial != "Todos") {
      data <- data %>%
        filter(Potencial_de_Poluicao_da_atividade == input$potencial)
    }
    
    if (input$categoria != "Todos") {
      data <- data %>%
        filter(Descricao_da_categoria == input$categoria)
    }
    
    if (input$situacao != "Todos") {
      data <- data %>%
        filter(Situacao_cadastral == input$situacao)
    }
    
   
    # Impressão detalhada para depuração
    print("Estrutura do dataframe 'data' após todas as filtragens:")
    print(str(data))
    print("Primeiras linhas do dataframe 'data':")
    print(head(data))
    
    # Assegurar que os nomes das colunas estejam corretos
    colnames(data) <- make.names(colnames(data))
    
    # Verificar novamente após renomear colunas
    print("Nomes das colunas após make.names:")
    print(colnames(data))
    
    # Converter para sf object
    data_sf <- st_as_sf(data, coords = c("Longitude", "Latitude"), crs = 4326, remove = FALSE)
    
    leaflet(data = data_sf) %>%
      addTiles() %>%
      addCircleMarkers(lng = ~Longitude, lat = ~Latitude, 
                       popup = ~paste(Municipio, "<br>", Estado, "<br>", Potencial_de_Poluicao_da_atividade, "<br>", Descricao_da_categoria, "<br>", Situacao_cadastral),
                       label = ~Situacao_cadastral,
                       radius = 5,  # Tamanho dos círculos
                       color = ~cores_situacao[Situacao_cadastral],  # Cor do contorno com base na situação cadastral
                       fillColor = ~cores_categoria[Descricao_da_categoria],  # Cor de preenchimento com base na categoria
                       fillOpacity = 0.7)  # Opacidade do preenchimento
  })
}

shinyApp(ui, server)
#ORIGINAL ACIMA



# Carregar um polígono simplificado do Brasil
brasil_polygon <- st_as_sf(maptools::wrld_simpl, crs = 4326) %>%
  filter(NAME == "Brazil")

# Interface do usuário (UI)
set.seed(42)
ui <- fluidPage(
  titlePanel("Pontos de Atividades no Brasil por Região"),
  sidebarLayout(
    sidebarPanel(
      selectInput("regiao", "Selecione a Região:", c("Todos", unique(CTF_BRASIL$Região))),
      selectInput("estado", "Selecione o Estado:", choices = NULL),
      selectInput("potencial", "Selecione o Potencial Poluidor:", choices = c("Todos", unique(CTF_BRASIL$Potencial_de_Poluicao_da_atividade))),
      selectInput("categoria", "Selecione a Descrição da Categoria:", choices = c("Todos", unique(CTF_BRASIL$Descricao_da_categoria))),
      selectInput("situacao", "Selecione a Situação Cadastral:", choices = c("Todos", unique(CTF_BRASIL$Situacao_cadastral))),
      selectInput("coord_erro", "Selecione Coordenadas:", c("Todos", "Coordenadas com Erro", "Coordenadas sem Erro")),
      actionButton("filtrar", "Aplicar Filtros")  # Botão para aplicar filtros
    ),
    mainPanel(
      withSpinner(leafletOutput("map"))  # Adiciona um spinner durante o carregamento do mapa
    )
  )
)

# Defina as cores para as situações cadastrais
cores_situacao <- c("Ativa" = "green", "Suspensa para Averiguações" = "yellow", "Encerrado" = "red")

# Defina um conjunto de cores para as categorias (aqui usamos uma paleta básica, mas pode ser ajustada conforme necessário)
categorias_unicas <- unique(CTF_BRASIL$Descricao_da_categoria)
cores_categoria <- rainbow(length(categorias_unicas))
names(cores_categoria) <- categorias_unicas

# Cor especial para pontos fora dos limites
cor_fora_limite <- "blue"

# Servidor (Server)
server <- function(input, output, session) {
  # Atualize as opções de estado com base na região selecionada
  observeEvent(input$regiao, {
    if (input$regiao == "Todos") {
      estados <- unique(CTF_BRASIL$Estado)
    } else {
      estados <- CTF_BRASIL %>%
        filter(Região == input$regiao) %>%
        pull(Estado) %>%
        unique()
    }
    updateSelectInput(session, "estado", choices = c("Todos", estados))
  })
  
  # Aplicar filtros e renderizar o mapa sob demanda
  observeEvent(input$filtrar, {
    data <- CTF_BRASIL %>%
      filter(
        (input$regiao == "Todos" | Região == input$regiao) &
          (input$estado == "Todos" | Estado == input$estado) &
          (input$potencial == "Todos" | Potencial_de_Poluicao_da_atividade == input$potencial) &
          (input$categoria == "Todos" | Descricao_da_categoria == input$categoria) &
          (input$situacao == "Todos" | Situacao_cadastral == input$situacao)
      )
    
    # Verificar a estrutura dos dados após a filtragem
    print("Estrutura dos dados após a filtragem:")
    print(str(data))
    
    # Assegurar que os nomes das colunas estejam corretos
    colnames(data) <- make.names(colnames(data))
    
    # Verificar a estrutura dos dados após a correção dos nomes das colunas
    print("Estrutura dos dados após a correção dos nomes das colunas:")
    print(str(data))
    
    # Converter para sf object
    data_sf <- st_as_sf(data, coords = c("Longitude", "Latitude"), crs = 4326, remove = FALSE)
    
    # Inicialize pontos_fora_limite como um data frame vazio
    pontos_fora_limite <- data.frame(Longitude = numeric(0), Latitude = numeric(0))
    
    if (input$regiao != "Todos" || input$estado != "Todos") {
      limites_regiao <- st_bbox(data_sf)
      pontos_fora_limite <- data %>%
        filter(!(Longitude >= as.numeric(limites_regiao["xmin"]) & Longitude <= as.numeric(limites_regiao["xmax"]) & 
                   Latitude >= as.numeric(limites_regiao["ymin"]) & Latitude <= as.numeric(limites_regiao["ymax"])))
    }
    
    # Verificar a estrutura de pontos_fora_limite
    print("Estrutura de pontos_fora_limite:")
    print(str(pontos_fora_limite))
    
    # Filtragem por coordenadas com erro ou sem erro
    if (input$coord_erro == "Coordenadas com Erro") {
      data_sf <- data_sf %>%
        filter(Longitude %in% pontos_fora_limite$Longitude & Latitude %in% pontos_fora_limite$Latitude)
    } else if (input$coord_erro == "Coordenadas sem Erro") {
      data_sf <- data_sf %>%
        filter(!(Longitude %in% pontos_fora_limite$Longitude & Latitude %in% pontos_fora_limite$Latitude))
    }
    
    # Verificar a estrutura de data_sf após a filtragem de coordenadas
    print("Estrutura de data_sf após a filtragem de coordenadas:")
    print(str(data_sf))
    
    # Renderize o mapa
    output$map <- renderLeaflet({
      leaflet(data = data_sf) %>%
        addTiles() %>%
        addCircleMarkers(
          lng = ~Longitude, lat = ~Latitude, 
          popup = ~paste("CNPJ:", CNPJ, "<br>", "Município:", Municipio, "<br>", Estado, "<br>", Potencial_de_Poluicao_da_atividade, "<br>", Descricao_da_categoria, "<br>", Situacao_cadastral),
          label = ~Situacao_cadastral,
          radius = 5,  # Tamanho dos círculos
          color = ~ifelse(Longitude %in% pontos_fora_limite$Longitude & Latitude %in% pontos_fora_limite$Latitude, cor_fora_limite, cores_situacao[Situacao_cadastral]),  # Cor do contorno com base na situação cadastral ou fora dos limites
          fillColor = ~cores_categoria[Descricao_da_categoria],  # Cor de preenchimento com base na categoria
          fillOpacity = 0.7,  # Opacidade do preenchimento
          clusterOptions = markerClusterOptions()  # Adiciona agrupamento de marcadores para melhorar a performance
        )
    })
  })
}

shinyApp(ui, server)
